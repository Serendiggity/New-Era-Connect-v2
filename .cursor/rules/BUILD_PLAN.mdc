---
alwaysApply: true
---
## **Phase 1: Build the Email Management UI**

**Goal:** To build the new features for email management *within* the new, clean architecture.

*   **Task 1.1: Create the Email Feature Module**
    *   **Action:** Create the directory `server/features/emails/`. Inside, create `emails.routes.ts` and `emails.service.ts`.

*   **Task 1.2: Update Database Schema**
    *   **Action:** Modify `shared/schema.ts`.
    *   **Logic:** Add the full Drizzle schema for `emailTemplates` and `emailDrafts` and their related Zod schemas and types.
    *   **Code:**
        ```typescript
        // ... (at the end of the file, before other type exports)
        export const emailTemplates = pgTable('email_templates', {
          id: serial('id').primaryKey(),
          name: text('name').notNull(),
          subject: text('subject').notNull(),
          body: text('body').notNull(),
          userId: text('user_id').notNull(),
          createdAt: timestamp('created_at').defaultNow().notNull(),
        });

        export const emailDrafts = pgTable('email_drafts', {
          id: serial('id').primaryKey(),
          contactId: integer('contact_id').references(() => contacts.id),
          leadGroupId: integer('lead_group_id').references(() => leadGroups.id),
          templateId: integer('template_id').references(() => emailTemplates.id),
          subject: text('subject').notNull(),
          body: text('body').notNull(),
          status: text('status').default('draft').notNull(),
          userId: text('user_id').notNull(),
          createdAt: timestamp('created_at').defaultNow().notNull(),
        });

        export const insertEmailTemplateSchema = createInsertSchema(emailTemplates).omit({
          id: true,
          createdAt: true,
        });

        export type EmailTemplate = typeof emailTemplates.$inferSelect;
        export type InsertEmailTemplate = z.infer<typeof insertEmailTemplateSchema>;
        export type EmailDraft = typeof emailDrafts.$inferSelect;
        ```
    *   **Follow-up Action:** Run `npm run db:push` to apply the schema changes.

*   **Task 1.3: Implement Email Template API**
    *   **Action:** In `server/features/emails/`, add the CRUD API endpoints for `/api/email-templates` to `emails.routes.ts` and the corresponding logic to `emails.service.ts`.

*   **Task 1.4: Implement Email Draft Generation API**
    *   **Action:** In `server/features/emails/`, add the `POST /api/email-drafts` endpoint and service logic. This service will call the *existing* `generateEmailDraft` function from `server/services/ai.ts`.

*   **Task 1.5: Build the Frontend UI**
    *   **Action:** Build the React components for managing templates and generating drafts, as detailed in the original build plan, using `useQuery` and `useMutation` to communicate with the new, cleanly architected API endpoints. 

---

## **Phase 2: Advanced Search Implementation**

**Goal:** To implement the frontend UI for the powerful Natural Language Search feature.

*   **Task 2.1: Create Search API Endpoint**
    *   **Action:** In `server/features/contacts/`, create a new route `GET /api/contacts/search` in `contacts.routes.ts`.
    *   **Logic:** This route will accept a `q` query parameter (e.g., `/api/contacts/search?q=tech contacts from last week`). It will pass this query string to the `processNaturalLanguageQuery` function in `server/services/ai.ts` to get back a structured Drizzle query object. It will then use this object to query the database and return the results.

*   **Task 2.2: Implement Search on the Frontend**
    *   **Action:** Modify the `ContactsPage` component (`client/src/pages/contacts.tsx`).
    *   **Logic:**
        1.  Add state to hold the search query from the search input field.
        2.  Use the `useDebounce` hook to prevent firing API calls on every keystroke.
        3.  Use TanStack Query's `useQuery` to call the `/api/contacts/search` endpoint, passing the debounced search query. The query should be disabled if the search box is empty.
        4.  The `ContactTable` component should be updated to display the results from the search query when it is active, and the full contact list otherwise. 